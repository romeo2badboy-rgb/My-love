name: RDPon - Hardened & Multi-Port
on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 3600

    env:
      # Ports we will open + verify
      PORTS: "3389,3822,80,443"
      TAILSCALE_MSI_URL: "https://pkgs.tailscale.com/stable/tailscale-setup-1.82.0-amd64.msi"
      RDP_USERNAME: "RDP"

    steps:
      - name: Prepare - show env
        run: echo "Preparing to open ports: $env:PORTS"
        shell: pwsh

      - name: Configure RDP, Services & Firewall (robust)
        shell: pwsh
        run: |
          $enableNLA = $env:ENABLE_NLA -eq "true"  # optional secret ENABLE_NLA=true to enable NLA
          Write-Host "Enable NLA? $enableNLA"

          # Enable Remote Desktop (allow connections)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force

          if ($enableNLA) {
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1 -Force
            # keep SecurityLayer default (0 = RDP, 1 = Negotiate, 2 = SSL)
          } else {
            # Disable NLA to maximize compatibility with simple RDP clients
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          }

          # Ensure TermService is set to Automatic and running
          Set-Service -Name TermService -StartupType Automatic
          Start-Service -Name TermService -ErrorAction SilentlyContinue

          # Firewall rules: remove old named rules then add robust rules on all profiles
          $ruleBase = "GH-RDPon-Rule"
          Get-NetFirewallRule -DisplayName "$ruleBase-*" -ErrorAction SilentlyContinue | Remove-NetFirewallRule -ErrorAction SilentlyContinue

          $ports = $env:PORTS.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
          foreach ($p in $ports) {
            # Add both TCP allow and ensure applied to All profiles (Domain,Private,Public)
            if (-not (Get-NetFirewallRule -DisplayName "$ruleBase-$p" -ErrorAction SilentlyContinue)) {
              New-NetFirewallRule -DisplayName "$ruleBase-$p" -Direction Inbound -LocalPort $p -Protocol TCP -Action Allow -Profile Any -Enabled True
            } else {
              Write-Host "Firewall rule for port $p already exists."
            }
          }

          # Diagnostics dump
          Write-Host "=== LISTENERS (netstat) ==="
          netstat -an | Select-String ":3389|:3822|:80|:443" | ForEach-Object { Write-Host $_ }

          Write-Host "=== CURRENT RDP LISTENER STATUS ==="
          Get-NetTCPConnection -LocalPort 3389 -State Listen -ErrorAction SilentlyContinue | Format-Table -AutoSize

      - name: Create local user with strong password (masked)
        shell: pwsh
        run: |
          Add-Type -AssemblyName System.Security
          $charSet = @{
            Upper   = [char[]](65..90)
            Lower   = [char[]](97..122)
            Number  = [char[]](48..57)
            Special = ([char[]](33..47) + [char[]](58..64) + [char[]](91..96) + [char[]](123..126))
          }

          $raw = @()
          $raw += $charSet.Upper | Get-Random -Count 4
          $raw += $charSet.Lower | Get-Random -Count 4
          $raw += $charSet.Number | Get-Random -Count 4
          $raw += $charSet.Special | Get-Random -Count 4
          $password = -join ($raw | Sort-Object { Get-Random })

          # Mask the password in Actions logs
          Write-Host "::add-mask::$password"

          $securePass = ConvertTo-SecureString $password -AsPlainText -Force

          if (Get-LocalUser -Name $env:RDP_USERNAME -ErrorAction SilentlyContinue) {
            Write-Host "User $($env:RDP_USERNAME) already exists. Resetting password and ensuring groups."
            Set-LocalUser -Name $env:RDP_USERNAME -Password $securePass
          } else {
            Write-Host "Creating user $($env:RDP_USERNAME)"
            New-LocalUser -Name $env:RDP_USERNAME -Password $securePass -AccountNeverExpires -UserMayNotChangePassword:$false
          }

          # Add to needed groups
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $env:RDP_USERNAME -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Administrators" -Member $env:RDP_USERNAME -ErrorAction SilentlyContinue

          # Export creds to GITHUB_ENV for later steps (masked)
          echo "RDP_USER=$env:RDP_USERNAME" >> $env:GITHUB_ENV
          echo "RDP_PASS=$password" >> $env:GITHUB_ENV

      - name: Install Tailscale (robust download + install)
        shell: pwsh
        run: |
          $installer = "$env:TEMP\tailscale.msi"
          Write-Host "Downloading Tailscale from $env:TAILSCALE_MSI_URL..."
          Invoke-WebRequest -Uri $env:TAILSCALE_MSI_URL -OutFile $installer -UseBasicParsing -ErrorAction Stop
          Write-Host "Installing Tailscale..."
          Start-Process msiexec.exe -ArgumentList "/i", "`"$installer`"", "/quiet", "/norestart" -Wait
          Remove-Item $installer -Force -ErrorAction SilentlyContinue
          Write-Host "Tailscale installed. Version:"
          & "$env:ProgramFiles\Tailscale\tailscale.exe" version

      - name: Connect Tailscale and wait for IP
        shell: pwsh
        env:
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          if (-not $env:TAILSCALE_AUTH_KEY) {
            Write-Error "Missing secret: TAILSCALE_AUTH_KEY"
            exit 1
          }
          $exe = "$env:ProgramFiles\Tailscale\tailscale.exe"
          if (-not (Test-Path $exe)) { Write-Error "Tailscale executable not found at $exe"; exit 1 }

          # Up with authkey and unique hostname
          & $exe up --authkey=$env:TAILSCALE_AUTH_KEY --hostname=gh-runner-$env:GITHUB_RUN_ID --accept-routes --accept-dns=false

          # robust wait for IPv4 address
          $tsIP = $null
          $retries = 0
          while (-not $tsIP -and $retries -lt 20) {
            $ipsRaw = & $exe ip -4 2>$null
            # take first non-empty line and first token
            $ips = ($ipsRaw -split "\r?\n" | Where-Object { $_ -match '\d+\.\d+\.\d+\.\d+' })
            if ($ips.Count -gt 0) {
              $tsIP = ($ips[0] -split '\s+')[0].Trim()
            }
            if (-not $tsIP) {
              Start-Sleep -Seconds 3
              $retries++
            }
          }

          if (-not $tsIP) {
            Write-Error "Tailscale IP not assigned after retries. Dumping status and exiting."
            & $exe status || Write-Host "tailscale status failed"
            exit 1
          }

          Write-Host "TAILSCALE_IP=$tsIP"
          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV

      - name: Local & Remote Port Checks (listen + connectivity)
        shell: pwsh
        run: |
          $ports = $env:PORTS.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
          $allGood = $true

          # 1) Check local listen on 3389 specifically
          $listen = Get-NetTCPConnection -LocalPort 3389 -State Listen -ErrorAction SilentlyContinue
          if ($null -eq $listen) {
            Write-Warning "RDP service is not listening on local port 3389. Attempting to restart TermService and re-check..."
            Restart-Service -Name TermService -Force
            Start-Sleep -Seconds 4
            $listen = Get-NetTCPConnection -LocalPort 3389 -State Listen -ErrorAction SilentlyContinue
            if ($null -eq $listen) {
              Write-Error "Local listener on 3389 not found after restart. This will likely block remote RDP."
              $allGood = $false
            } else {
              Write-Host "Local listener on 3389 is present after restart."
            }
          } else {
            Write-Host "Local RDP listener OK."
          }

          # 2) From runner -> Tailscale IP check each port (TCP)
          $remote = $env:TAILSCALE_IP
          if (-not $remote) { Write-Error "No Tailscale IP set"; exit 1 }

          foreach ($p in $ports) {
            $ok = $false
            # run Test-NetConnection with timeout attempts
            for ($i=0; $i -lt 6; $i++) {
              $t = Test-NetConnection -ComputerName $remote -Port $p -InformationLevel Detailed -WarningAction SilentlyContinue
              if ($t.TcpTestSucceeded) { $ok = $true; break }
              Start-Sleep -Seconds 3
            }
            if ($ok) {
              Write-Host "✅ Remote port $p reachable on $remote"
            } else {
              Write-Warning "❌ Remote port $p NOT reachable on $remote"
              $allGood = $false
            }
          }

          if (-not $allGood) {
            Write-Error "One or more checks failed. See logs above for diagnostics. Exiting with failure to avoid exposing a broken endpoint."
            # Provide quick diagnostics
            Write-Host "`n--- DIAGNOSTICS ---"
            Write-Host "Local netstat:"
            netstat -an | Select-String ":3389|:3822|:80|:443" | ForEach-Object { Write-Host $_ }
            Write-Host "`nRDP listener details:"
            Get-NetTCPConnection -LocalPort 3389 -ErrorAction SilentlyContinue | Format-Table -AutoSize
            Write-Host "`nFirewall rules:"
            Get-NetFirewallRule -DisplayName "GH-RDPon-*" | Format-Table DisplayName,Enabled,Direction,Profile -AutoSize
            exit 1
          }

      - name: Create .rdp file (downloadable) and small README
        shell: pwsh
        run: |
          $ip = $env:TAILSCALE_IP
          $user = $env:RDP_USER
          $file = "$env:GITHUB_WORKSPACE\rdp-access-${GITHUB_RUN_ID}.rdp"

          $rdpContent = @"
full address:s:$ip:3389
username:s:$user
prompt for credentials:i:1
authentication level:i:0
enablecredsspsupport:i:0
"@

          $rdpContent | Out-File -FilePath $file -Encoding ASCII
          Write-Host "Created RDP file at: $file"
          echo "RDP_FILE=$file" >> $env:GITHUB_ENV

          $readme = "$env:GITHUB_WORKSPACE/README-RDP.txt"
          @"
Tailscale IP: $ip
Username: $user
(Password masked in logs. Use secret/outputs or check Actions mask)
Ports opened: $env:PORTS
RDP file: rdp-access-${GITHUB_RUN_ID}.rdp
"@ | Out-File -FilePath $readme -Encoding UTF8

      - name: Upload RDP file & README as artifact
        uses: actions/upload-artifact@v4
        with:
          name: rdp-access-${{ github.run_id }}
          path: |
            ./${{ github.workspace }}/rdp-access-${{ github.run_id }}.rdp
            ./${{ github.workspace }}/README-RDP.txt

      - name: Final output & keepalive
        shell: pwsh
        run: |
          Write-Host "`n=== READY ==="
          Write-Host "Tailscale IP : $env:TAILSCALE_IP"
          Write-Host "Username     : $env:RDP_USER"
          Write-Host "Password     : (masked in logs) - see workflow masked output"
          Write-Host "Artifact     : rdp-access-${GITHUB_RUN_ID}.rdp (download from workflow artifacts)"
          Write-Host "Ports        : $env:PORTS"
          Write-Host "================`n"

          # Keep alive (finite heartbeats so workflow doesn't look like stuck)
          for ($i=0; $i -lt 120; $i++) {
            Write-Host "[$(Get-Date)] Session active - will auto-check status every 60s. Stop workflow to terminate."
            Start-Sleep -Seconds 60
          }
          Write-Host "Keepalive finished; exiting."
